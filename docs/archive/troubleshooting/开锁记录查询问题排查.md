# 开锁记录查询问题排查报告

## 问题描述

点击"开锁记录"按钮后，App 界面卡死，无法显示数据。

## 服务器日志分析

```
260118 16:20:29 收到query消息：{"type":"query","target":"unlock_logs","data":{"limit":20,"offset":0},"seq_id":"1768724418494_0"}
260118 16:20:29 收到数据查询请求: target=unlock_logs
260118 16:20:29 App 连接已注销: e8:f6:0a:83:8f:50, 剩余连接数: 0
260118 16:20:29 App 连接资源已清理
```

## 问题根因

**服务器端在处理 `query` 消息时出现异常，导致连接被断开。**

可能的原因：

1. 数据库查询失败（连接超时、SQL 错误等）
2. 服务器端代码异常（未捕获的 Exception）
3. 权限验证失败
4. 消息格式解析错误

## 客户端已实施的修复

### 1. 响应格式兼容性处理

根据协议 v2.3，服务器响应格式为：

```json
{
  "type": "query_result",
  "target": "unlock_logs",
  "status": "success",
  "data": {
    "records": [...],
    "total": 201,
    "limit": 100,
    "offset": 0
  }
}
```

修改了 `handleQueryResult` 方法，兼容两种格式：

- 新格式：`data.records` 是数组
- 旧格式：`data` 直接是数组

### 2. 连接状态检查

在 `sendQuery` 方法中添加连接状态检查，如果未连接则立即返回错误。

### 3. 错误处理增强

- 添加 try-catch 捕获发送异常
- 连接断开时提供更详细的错误信息
- 触发错误事件让 UI 可以显示友好提示

### 4. 超时保护机制（待实施）

建议添加查询超时保护：

- 发送查询后启动 10 秒定时器
- 如果超时且连接断开，触发错误事件
- 收到响应后清除定时器

## 服务器端需要排查的问题

### 1. 检查数据库查询

```python
# 检查 get_unlock_logs 方法
# 文件：core/providers/doorlock/database.py

def get_unlock_logs(device_id, limit=100, offset=0, method=None, result=None):
    try:
        # 确保数据库连接正常
        # 确保 SQL 查询语法正确
        # 确保返回格式符合协议规范
        pass
    except Exception as e:
        logger.error(f"查询开锁记录失败: {e}")
        # 不要直接断开连接，应该返回错误响应
        return {"status": "error", "error": str(e)}
```

### 2. 检查异常处理

```python
# 文件：core/handle/textHandler.py 或类似文件

async def handle_query(self, msg, websocket):
    try:
        target = msg.get("target")
        data = msg.get("data", {})

        if target == "unlock_logs":
            result = await self.db.get_unlock_logs(
                device_id=self.device_id,
                limit=data.get("limit", 100),
                offset=data.get("offset", 0)
            )

            # 发送响应
            await websocket.send(json.dumps({
                "type": "query_result",
                "target": "unlock_logs",
                "status": "success",
                "data": result
            }))

    except Exception as e:
        logger.error(f"处理查询请求失败: {e}", exc_info=True)
        # 发送错误响应，而不是断开连接
        await websocket.send(json.dumps({
            "type": "query_result",
            "target": target,
            "status": "error",
            "error": str(e)
        }))
```

### 3. 检查连接管理

确保在处理消息时不会意外注销连接：

```python
# 检查是否有代码在处理 query 时调用了 unregister_connection
# 或者检查是否有超时机制误判连接为无效
```

## 测试建议

### 1. 服务器端日志增强

```python
logger.info(f"开始处理 query 请求: target={target}, data={data}")
logger.info(f"数据库查询完成，返回 {len(records)} 条记录")
logger.info(f"发送响应: {response}")
```

### 2. 数据库连接测试

```python
# 测试数据库连接是否正常
# 测试 unlock_logs 表是否存在
# 测试查询是否能正常执行
```

### 3. 模拟测试

使用 WebSocket 客户端工具（如 wscat）直接发送 query 消息：

```bash
wscat -c ws://localhost:8000/ws/app

# 发送认证
{"type":"hello","device_id":"AA:BB:CC:DD:EE:FF","app_id":"test_user","client_type":"app"}

# 发送查询
{"type":"query","target":"unlock_logs","data":{"limit":20,"offset":0},"seq_id":"test_001"}
```

观察服务器响应和日志。

## 临时解决方案

如果服务器端问题短期无法修复，可以在客户端：

1. 添加重试机制
2. 显示友好的错误提示
3. 提供"刷新"按钮让用户手动重试
4. 记录详细的错误日志供排查

## 下一步行动

1. **服务器端**：检查 query 处理逻辑，添加异常捕获，确保不会断开连接
2. **客户端**：已完成基础错误处理，可以继续优化用户体验
3. **测试**：使用工具模拟请求，复现问题并验证修复

## 更新记录

- 2026-01-18：初始版本，分析问题并提供客户端修复方案
