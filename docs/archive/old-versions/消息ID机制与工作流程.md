# 消息 ID 机制与工作流程

## 一、概述

本系统采用统一的 `seq_id`（序列号）机制实现消息追踪、确认和防重放。该机制贯穿 App → Server → ESP32 的完整通信链路。

---

## 二、seq_id 定义

### 2.1 基本属性

| 属性 | 说明 |
|------|------|
| 生成方 | App 端 |
| 格式 | `{毫秒时间戳}_{递增序号}` |
| 示例 | `1702234567890_0`、`1702234567890_1` |
| 唯一性 | 同一 App 实例内全局唯一 |
| 生命周期 | 从命令发送到收到最终响应 |

### 2.2 生成规则

1. 获取当前毫秒级时间戳
2. 获取当前递增序号（从 0 开始，每次发送命令后 +1）
3. 拼接为 `{时间戳}_{序号}` 格式

### 2.3 携带规则

| 消息类型 | 方向 | 是否携带 | 说明 |
|----------|------|----------|------|
| 命令消息 | App → Server | ✅ 必须 | App 生成并附加 |
| server_ack | Server → App | ✅ 回填 | 服务器原样返回 |
| 命令转发 | Server → ESP32 | ✅ 透传 | 保持不变 |
| ack | ESP32 → Server | ✅ 回填 | ESP32 原样返回 |
| ack 转发 | Server → App | ✅ 透传 | 保持不变 |
| 推送消息 | Server → App | ❌ 无 | 服务器主动推送，无需确认 |

---

## 三、确认机制

### 3.1 两级确认

系统采用两级确认机制：

| 级别 | 确认消息 | 含义 |
|------|----------|------|
| 第一级 | `server_ack` | 服务器已接收并处理消息 |
| 第二级 | `ack` | ESP32 已执行命令 |

### 3.2 server_ack 错误码

| code | 含义 | App 处理方式 |
|------|------|--------------|
| 0 | 成功 | 继续等待 ESP32 的 ack |
| 1 | 设备离线 | 提示用户，结束等待 |
| 2 | 参数错误 | 检查命令格式 |
| 3 | 未认证 | 重新连接认证 |
| 4 | 内部错误 | 稍后重试 |
| 5 | 重复消息 | 忽略，已处理过 |

### 3.3 ESP32 ack 错误码

| code | 含义 |
|------|------|
| 0 | 执行成功 |
| 1 | 设备忙碌 |
| 2 | 参数错误 |
| 3 | 硬件故障 |
| 4 | 执行超时 |
| 5 | 未授权 |
| 6 | 资源不足 |
| 7 | 不支持 |

---

## 四、工作流程

### 4.1 正常流程（命令执行成功）

```
┌─────┐                    ┌────────┐                    ┌───────┐
│ App │                    │ Server │                    │ ESP32 │
└──┬──┘                    └───┬────┘                    └───┬───┘
   │                           │                             │
   │  ① 命令 (seq_id=xxx)      │                             │
   │ ─────────────────────────►│                             │
   │                           │                             │
   │                           │ ② 检查 seq_id 是否重复       │
   │                           │    缓存 seq_id               │
   │                           │                             │
   │  ③ server_ack (code=0)    │                             │
   │ ◄─────────────────────────│                             │
   │                           │                             │
   │                           │  ④ 转发命令 (seq_id=xxx)     │
   │                           │ ────────────────────────────►│
   │                           │                             │
   │                           │                             │ ⑤ 执行命令
   │                           │                             │
   │                           │  ⑥ ack (seq_id=xxx, code=0) │
   │                           │ ◄────────────────────────────│
   │                           │                             │
   │  ⑦ ack 转发 (code=0)      │                             │
   │ ◄─────────────────────────│                             │
   │                           │                             │
   │ ⑧ 匹配 seq_id             │                             │
   │    确认执行成功            │                             │
   │                           │                             │
```

**流程说明：**

1. App 生成 seq_id，发送命令
2. Server 检查 seq_id 是否重复，若不重复则缓存
3. Server 返回 server_ack，表示已接收
4. Server 将命令透传给 ESP32（保留 seq_id）
5. ESP32 执行命令（如开锁）
6. ESP32 返回 ack，携带相同的 seq_id
7. Server 将 ack 转发给 App
8. App 通过 seq_id 匹配，确认命令执行成功

### 4.2 重复消息流程（防重放）

```
┌─────┐                    ┌────────┐
│ App │                    │ Server │
└──┬──┘                    └───┬────┘
   │                           │
   │  ① 命令 (seq_id=xxx)      │
   │ ─────────────────────────►│
   │                           │
   │                           │ ② 缓存 seq_id
   │                           │
   │  ③ server_ack (code=0)    │
   │ ◄─────────────────────────│
   │                           │
   │  ④ 网络抖动，重发相同命令   │
   │     (seq_id=xxx)          │
   │ ─────────────────────────►│
   │                           │
   │                           │ ⑤ 检查 seq_id → 已存在！
   │                           │
   │  ⑥ server_ack (code=5)    │
   │ ◄─────────────────────────│
   │                           │
   │ ⑦ 收到 code=5，忽略       │
   │                           │
```

**流程说明：**

1. App 发送命令
2. Server 缓存 seq_id
3. Server 返回成功确认
4. 因网络问题，App 重发相同命令（相同 seq_id）
5. Server 检测到 seq_id 已存在
6. Server 返回 code=5（重复消息）
7. App 收到 code=5，忽略该响应，不重复处理

### 4.3 设备离线流程

```
┌─────┐                    ┌────────┐                    ┌───────┐
│ App │                    │ Server │                    │ ESP32 │
└──┬──┘                    └───┬────┘                    └───┬───┘
   │                           │                             │
   │  ① 命令 (seq_id=xxx)      │                          (离线)
   │ ─────────────────────────►│                             ✗
   │                           │                             
   │                           │ ② 检查 ESP32 状态 → 离线    
   │                           │                             
   │  ③ server_ack (code=1)    │                             
   │ ◄─────────────────────────│                             
   │                           │                             
   │ ④ 提示用户设备离线        │                             
   │    结束等待               │                             
   │                           │                             
```

**流程说明：**

1. App 发送命令
2. Server 检测到 ESP32 不在线
3. Server 返回 code=1（设备离线）
4. App 提示用户设备离线，不再等待 ESP32 响应

### 4.4 超时重传流程

```
┌─────┐                    ┌────────┐
│ App │                    │ Server │
└──┬──┘                    └───┬────┘
   │                           │
   │  ① 命令 (seq_id=xxx)      │
   │ ─────────────────────────►│
   │                           │
   │  ② 启动 3 秒超时计时器     │
   │                           │
   │     ... 3 秒无响应 ...     │
   │                           │
   │  ③ 超时，重传 (seq_id=xxx) │
   │ ─────────────────────────►│
   │                           │
   │  ④ server_ack (code=0)    │
   │ ◄─────────────────────────│
   │                           │
   │  ⑤ 取消计时器             │
   │                           │
```

**重传策略：**

| 参数 | 值 |
|------|-----|
| 超时时间 | 3 秒 |
| 最大重试次数 | 3 次 |
| 重传时 seq_id | 保持不变 |

---

## 五、服务器端 seq_id 管理

### 5.1 缓存策略

| 参数 | 值 |
|------|-----|
| 缓存分组 | 按 app_id 分组 |
| 每组容量 | 最近 100 条 |
| 淘汰策略 | FIFO（先进先出） |

### 5.2 处理流程

1. 收到 App 命令
2. 提取 seq_id 和 app_id
3. 检查该 app_id 的缓存中是否存在该 seq_id
4. 若存在 → 返回 code=5，不处理
5. 若不存在 → 加入缓存，继续处理

---

## 六、消息类型与 seq_id

### 6.1 需要 seq_id 的消息（App 发送的命令）

| type | 说明 |
|------|------|
| lock_control | 锁控命令 |
| dev_control | 设备控制 |
| user_mgmt | 用户管理 |
| system | 系统命令 |
| face_management | 人脸管理 |
| query | 数据查询 |
| media_download | 媒体下载 |
| media_download_chunk | 分片下载 |

### 6.2 不需要 seq_id 的消息（服务器推送）

| type | 说明 |
|------|------|
| device_status | 设备上下线通知 |
| status_report | 状态上报 |
| event_report | 事件上报 |
| log_report | 开锁日志 |
| visit_notification | 到访通知 |

---

## 七、设计优势

| 优势 | 说明 |
|------|------|
| 简洁统一 | 全链路使用同一个 seq_id，无需维护映射关系 |
| 端到端追踪 | 从 App 到 ESP32 可完整追踪消息 |
| 防重放 | 服务器缓存机制防止重复执行 |
| 可靠传输 | 超时重传机制保证消息送达 |
| 易于调试 | 通过 seq_id 可快速定位问题 |

---

**文档版本：** v1.0  
**最后更新：** 2024-12-11
