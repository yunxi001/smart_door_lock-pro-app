# 命令分类与超时重传策略

## 命令分类

### 1. 与设备交互的命令（不重传）

这些命令需要 ESP32 设备执行，由于设备可能正在执行其他任务或需要用户物理操作，**不进行重传**。

#### 1.1 用户管理命令 (`user_mgmt`)

- **超时时间**: 90秒
- **重传次数**: 0次
- **原因**: 需要用户在设备前进行物理操作（按指纹、刷卡等）

```typescript
{
  type: "user_mgmt",
  category: "finger" | "nfc" | "password",
  command: "add" | "del" | "query" | "set"
}
```

#### 1.2 设备控制命令 (`lock_control`, `dev_control`)

- **超时时间**: 20秒
- **重传次数**: 0次
- **原因**: 设备可能正在执行其他任务，重传可能导致重复执行

```typescript
// 锁控制
{
  type: "lock_control",
  command: "unlock" | "lock" | "temp_code"
}

// 设备控制
{
  type: "dev_control",
  target: "beep" | "light" | "oled"
}
```

---

### 2. 与服务器交互的命令（需要重传）

这些命令由服务器直接处理，不涉及设备操作，**需要进行重传**以确保可靠性。

- **超时时间**: 3秒
- **重传次数**: 3次
- **重传策略**: 使用相同的 `seq_id`

#### 2.1 系统命令 (`system`)

```typescript
{
  type: "system",
  command: "start_monitor" | "stop_monitor"
}
```

#### 2.2 查询命令 (`query`)

```typescript
{
  type: "query",
  target: "status" | "status_history" | "events" | "unlock_logs" | "media_files"
}
```

#### 2.3 人脸管理命令 (`face_management`)

```typescript
{
  type: "face_management",
  action: "register" | "get_persons" | "delete_person" | "update_permission" | "get_visits"
}
```

#### 2.4 媒体下载命令 (`media_download`, `media_download_chunk`)

```typescript
{
  type: "media_download",
  file_id: number | file_path: string
}

{
  type: "media_download_chunk",
  file_id: number,
  chunk_index: number
}
```

---

## 配置汇总表

| 命令类型               | 超时时间 | 重传次数 | 交互对象 | 说明                   |
| ---------------------- | -------- | -------- | -------- | ---------------------- |
| `user_mgmt`            | 90秒     | 0次      | ESP32    | 需要用户物理操作       |
| `lock_control`         | 20秒     | 0次      | ESP32    | 设备控制，避免重复执行 |
| `dev_control`          | 20秒     | 0次      | ESP32    | 设备控制，避免重复执行 |
| `system`               | 3秒      | 3次      | Server   | 服务器处理             |
| `query`                | 3秒      | 3次      | Server   | 数据库查询             |
| `face_management`      | 3秒      | 3次      | Server   | 人脸数据管理           |
| `media_download`       | 3秒      | 3次      | Server   | 文件下载               |
| `media_download_chunk` | 3秒      | 3次      | Server   | 分片下载               |

---

## 重传机制说明

### 重传时使用相同的 seq_id

重传时必须使用与初次发送时相同的 `seq_id`，这样：

1. 服务器可以识别重复消息（通过 seq_id 缓存）
2. 客户端可以正确匹配响应
3. 避免同一命令被执行多次

```typescript
// 初次发送
{
  type: "query",
  seq_id: "1702234567890_001",  // 生成的 seq_id
  target: "status"
}

// 超时后重传（使用相同的 seq_id）
{
  type: "query",
  seq_id: "1702234567890_001",  // 保持不变
  target: "status"
}
```

### 服务器防重放机制

服务器维护 seq_id 缓存：

- 收到消息时检查 seq_id 是否已存在
- 已存在则返回 `server_ack` (code=5, 重复消息)
- 不会重复执行命令

---

## 代码实现

### 配置常量

```typescript
// 与设备交互的命令（不重传）
const USER_MGMT_TIMEOUT = 90000; // 90秒
const DEVICE_CONTROL_TIMEOUT = 20000; // 20秒
const DEVICE_COMMAND_MAX_RETRIES = 0; // 不重传

// 与服务器交互的命令（需要重传）
const SERVER_COMMAND_TIMEOUT = 3000; // 3秒
const SERVER_COMMAND_MAX_RETRIES = 3; // 重传3次
```

### 自动配置逻辑

```typescript
private getCommandConfig(commandType: string, options?: CommandOptions) {
  // 与设备交互的命令
  const deviceCommands = ["user_mgmt", "lock_control", "dev_control"];

  if (deviceCommands.includes(commandType)) {
    if (commandType === "user_mgmt") {
      return { timeout: 90000, maxRetries: 0 };
    }
    return { timeout: 20000, maxRetries: 0 };
  }

  // 与服务器交互的命令
  return { timeout: 3000, maxRetries: 3 };
}
```

### 重传逻辑

```typescript
private handleTimeout(seqId: string, maxRetries: number) {
  const pending = this.pendingCommands.get(seqId);

  if (pending.retryCount < maxRetries) {
    pending.retryCount++;
    // 重传时使用相同的命令对象（包含相同的 seq_id）
    this.ws.send(JSON.stringify(pending.command));
  } else {
    // 超时失败
    this.clearPendingCommand(seqId, "请求超时");
  }
}
```

---

## 使用示例

### 用户管理命令（90秒超时，不重传）

```typescript
deviceService.sendUserMgmtCommand("finger", "add", 0);
// 日志: 发送指纹添加命令 (90秒超时，不重传)
```

### 设备控制命令（20秒超时，不重传）

```typescript
deviceService.sendCommand({
  type: "lock_control",
  command: "unlock",
  duration: 5,
});
// 自动配置: 20秒超时，0次重传
```

### 查询命令（3秒超时，重传3次）

```typescript
deviceService.sendQuery("unlock_logs", { limit: 100 });
// 日志: 发送查询命令: 开锁日志 (3秒超时，重传3次)
// 如果超时，会自动重传，使用相同的 seq_id
```

---

## 设计考虑

### 为什么设备命令不重传？

1. **避免重复执行**: 开锁命令重传可能导致门被多次开启
2. **设备状态不确定**: 设备可能正在执行其他任务
3. **用户体验**: 用户管理命令需要用户在场，重传会造成困扰

### 为什么服务器命令需要重传？

1. **网络不稳定**: 移动网络可能出现丢包
2. **服务器可靠**: 服务器有防重放机制，重传是安全的
3. **提高成功率**: 重传可以显著提高命令成功率

### 为什么重传使用相同的 seq_id？

1. **防止重复执行**: 服务器通过 seq_id 识别重复消息
2. **响应匹配**: 客户端通过 seq_id 匹配响应
3. **审计追踪**: 同一命令的所有尝试使用相同 ID，便于日志分析

---

**更新时间**: 2024-12-11
**版本**: v1.0
