# 智能门锁 Pro - 协议更新总结 v2.4

## 更新日期

2024-12-11

## 版本说明

从 v2.3 升级到 v2.4，主要更新超时和重传策略

---

## 主要变更

### 1. 命令分类调整

将所有命令明确分为两大类，采用不同的超时和重传策略：

#### 📱 与设备交互的命令（不重传）

| 命令类型       | 超时时间 | 重传次数 | 原因                               |
| -------------- | -------- | -------- | ---------------------------------- |
| `user_mgmt`    | 90秒     | 0次      | 需要用户物理操作（按指纹、刷卡等） |
| `lock_control` | 20秒     | 0次      | 避免重复执行（如重复开锁）         |
| `dev_control`  | 20秒     | 0次      | 避免重复执行（如重复开灯）         |

**设计考虑**：

- 用户管理命令需要用户在设备前进行物理操作，时间不可控
- 设备控制命令可能导致物理动作，重传会造成重复执行
- 设备可能正在执行其他任务，重传会增加负担

#### 🖥️ 与服务器交互的命令（需要重传）

| 命令类型               | 超时时间 | 重传次数 | 说明         |
| ---------------------- | -------- | -------- | ------------ |
| `system`               | 3秒      | 3次      | 监控模式控制 |
| `query`                | 3秒      | 3次      | 数据库查询   |
| `face_management`      | 3秒      | 3次      | 人脸数据管理 |
| `media_download`       | 3秒      | 3次      | 文件下载     |
| `media_download_chunk` | 3秒      | 3次      | 分片下载     |

**设计考虑**：

- 服务器命令不涉及物理操作，重传是安全的
- 服务器有防重放机制（seq_id 缓存），可以识别重复消息
- 网络不稳定时，重传可以显著提高成功率

---

### 2. 重传机制优化

#### 重传时使用相同的 seq_id

```typescript
// 初次发送
{
  type: "query",
  seq_id: "1702234567890_001",  // 生成的 seq_id
  target: "status"
}

// 超时后重传（使用相同的 seq_id）
{
  type: "query",
  seq_id: "1702234567890_001",  // 保持不变
  target: "status"
}
```

**好处**：

1. 服务器可以识别重复消息（通过 seq_id 缓存）
2. 客户端可以正确匹配响应
3. 避免同一命令被执行多次
4. 便于日志追踪和问题排查

#### 服务器防重放机制

- 服务器维护最近 100 条 seq_id 缓存（按 app_id 分组）
- 收到重复消息时返回 `server_ack` (code=5, 重复消息)
- 不会重复执行命令

---

### 3. 代码实现

#### 配置常量

```typescript
// 与设备交互的命令（不重传）
const USER_MGMT_TIMEOUT = 90000; // 90秒
const DEVICE_CONTROL_TIMEOUT = 20000; // 20秒
const DEVICE_COMMAND_MAX_RETRIES = 0; // 不重传

// 与服务器交互的命令（需要重传）
const SERVER_COMMAND_TIMEOUT = 3000; // 3秒
const SERVER_COMMAND_MAX_RETRIES = 3; // 重传3次
```

#### 自动配置逻辑

```typescript
private getCommandConfig(commandType: string, options?: CommandOptions) {
  // 与设备交互的命令
  const deviceCommands = ["user_mgmt", "lock_control", "dev_control"];

  if (deviceCommands.includes(commandType)) {
    if (commandType === "user_mgmt") {
      return { timeout: 90000, maxRetries: 0 };
    }
    return { timeout: 20000, maxRetries: 0 };
  }

  // 与服务器交互的命令
  return { timeout: 3000, maxRetries: 3 };
}
```

#### 用户可覆盖配置

```typescript
// 用户可以显式指定超时和重传配置
service.sendCommand(
  { type: "query", target: "status" },
  { timeout: 5000, maxRetries: 2 }, // 覆盖默认配置
);
```

---

### 4. 更新的文件

#### 代码文件

- ✅ `services/DeviceService.ts`
  - 新增 `getCommandConfig()` 方法
  - 更新 `sendCommand()` 方法
  - 更新 `handleTimeout()` 方法
  - 更新所有命令发送方法的注释

#### 文档文件

- ✅ `docs/智能猫眼门锁系统-服务器与App通信协议规范-v2.3.md`
  - 更新第 3.6 节：重传策略建议
- ✅ `docs/命令分类与超时重传策略.md`
  - 新增详细说明文档
- ✅ `docs/协议更新总结-v2.4.md`
  - 本文档

#### 测试文件

- ✅ `test/timeoutRetry.test.ts`
  - 完全重写测试用例
  - 新增设备命令超时测试（不重传）
  - 新增服务器命令超时和重传测试
  - 新增用户自定义配置测试
  - **测试结果**: 13/13 通过 ✅

---

## 使用示例

### 用户管理命令（90秒超时，不重传）

```typescript
deviceService.sendUserMgmtCommand("finger", "add", 0);
// 日志: 发送指纹添加命令 (90秒超时，不重传)
```

### 设备控制命令（20秒超时，不重传）

```typescript
deviceService.sendCommand({
  type: "lock_control",
  command: "unlock",
  duration: 5,
});
// 自动配置: 20秒超时，0次重传
```

### 查询命令（3秒超时，重传3次）

```typescript
deviceService.sendQuery("unlock_logs", { limit: 100 });
// 日志: 发送查询命令: 开锁日志 (3秒超时，重传3次)
// 如果超时，会自动重传，使用相同的 seq_id
```

### 人脸管理命令（3秒超时，重传3次）

```typescript
deviceService.sendFaceManagement("get_persons");
// 日志: 发送人脸管理命令: 获取人员列表 (3秒超时，重传3次)
```

---

## 向后兼容性

### ✅ 完全兼容

- 所有现有的命令发送方法保持不变
- 自动应用新的超时和重传策略
- 用户可以通过 `CommandOptions` 覆盖默认配置

### 🔄 行为变更

| 命令类型       | v2.3 行为         | v2.4 行为             | 影响        |
| -------------- | ----------------- | --------------------- | ----------- |
| `user_mgmt`    | 90秒超时，0次重传 | 90秒超时，0次重传     | 无变化 ✅   |
| `lock_control` | 3秒超时，3次重传  | **20秒超时，0次重传** | ⚠️ 不再重传 |
| `dev_control`  | 3秒超时，3次重传  | **20秒超时，0次重传** | ⚠️ 不再重传 |
| `query`        | 3秒超时，3次重传  | 3秒超时，3次重传      | 无变化 ✅   |
| `system`       | 3秒超时，3次重传  | 3秒超时，3次重传      | 无变化 ✅   |

**注意**: 设备控制命令不再重传，这是为了避免重复执行（如重复开锁）。如果需要重传，可以显式指定配置。

---

## 测试覆盖

### 测试文件: `test/timeoutRetry.test.ts`

#### ✅ 设备命令超时机制（不重传）

- 用户管理命令应该使用 90 秒超时，不重传
- 设备控制命令应该使用 20 秒超时，不重传
- dev_control 命令应该使用 20 秒超时，不重传

#### ✅ 服务器命令超时和重传机制

- 服务器命令应该在 3 秒后触发超时并重传
- 服务器命令应该最多重试 3 次
- 重传时应该使用相同的 seq_id
- face_management 命令应该使用 3 秒超时，重传 3 次

#### ✅ 用户自定义超时配置

- 应该允许用户覆盖默认超时配置
- 设备命令默认不重传，但可以通过配置启用

#### ✅ server_ack 响应处理

- 收到 server_ack (code=0) 后应该继续等待 ack
- 收到 server_ack (code=1) 后应该清理等待队列
- 收到 server_ack (code=5) 后应该清理队列但不触发错误
- 收到 ack 后应该清理等待队列并触发成功回调

**测试结果**: 13/13 通过 ✅

---

## 迁移指南

### 对于应用开发者

1. **无需修改代码**: 所有命令会自动应用新的超时和重传策略
2. **注意行为变更**: 设备控制命令不再重传，如果需要重传，请显式配置
3. **日志变化**: 日志消息会显示超时和重传配置

### 对于服务器开发者

1. **防重放机制**: 确保服务器正确实现 seq_id 缓存
2. **重复消息处理**: 重复消息应返回 `server_ack` (code=5)
3. **日志记录**: 记录重复消息以便排查问题

---

## 常见问题

### Q: 为什么设备命令不重传？

A: 设备命令可能导致物理动作（如开锁、开灯），重传会造成重复执行。设备可能正在执行其他任务，重传会增加负担。

### Q: 如果设备命令超时怎么办？

A: 用户可以手动重试，或者显式配置重传：

```typescript
service.sendCommand(
  { type: "lock_control", command: "unlock" },
  { timeout: 20000, maxRetries: 1 },
);
```

### Q: 服务器命令为什么需要重传？

A: 服务器命令不涉及物理操作，重传是安全的。网络不稳定时，重传可以显著提高成功率。服务器有防重放机制，可以识别重复消息。

### Q: 重传时为什么使用相同的 seq_id？

A: 这样服务器可以识别重复消息，避免重复执行。客户端也可以正确匹配响应。

---

## 下一步计划

- [ ] 监控设备命令的超时率，评估 20 秒是否合适
- [ ] 收集用户反馈，优化超时和重传策略
- [ ] 考虑为不同的设备控制命令设置不同的超时时间
- [ ] 添加命令执行时间统计，用于性能优化

---

**文档维护者**: 毕业设计项目组  
**最后更新**: 2024-12-11  
**版本**: v2.4
