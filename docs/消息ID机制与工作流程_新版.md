# 消息 ID 机制与工作流程

> 版本：v2.4  
> 更新日期：2026-01-16  
> 适用于：智能猫眼门锁系统

---

## 一、系统架构概览

### 1.1 四端通信架构

```
┌─────────┐         ┌────────────┐         ┌─────────┐         ┌─────────┐
│   App   │◄───────►│   Server   │◄───────►│  ESP32  │◄───────►│  STM32  │
└─────────┘         └────────────┘         └─────────┘         └─────────┘
   WebSocket           WebSocket              UART
```

### 1.2 各端职责

| 端 | 职责 |
|----|------|
| App | 命令发起方，生成 seq_id，展示结果 |
| Server | 中转路由，防重放检查，消息转发 |
| ESP32 | 协议转换，WebSocket 与 UART，两级确认 |
| STM32 | 硬件执行，开锁、指纹、NFC 等操作 |

### 1.3 消息 ID 定义

| 端 | 字段名 | 说明 |
|----|--------|------|
| App | seq_id | App 生成，格式：时间戳_序号 |
| Server | seq_id | 透传 App 的 seq_id |
| ESP32 | seq_id | 与 App/Server 统一使用 seq_id |
| STM32 | 无 | UART 协议不支持消息 ID |

---

## 二、整体工作流程（重点）

### 2.1 二级确认机制

| 级别 | 消息名称 | 发送方 | 含义 | 携带 seq_id |
|------|----------|--------|------|-------------|
| 第一级 | server_ack | Server | 服务器已收到命令 | ✅ |
| 第二级 | ack | ESP32 | 命令执行完成 | ✅ |

**关键区分**：
- `esp32_ack`：ESP32 收到命令后立即发送，表示"命令已收到，开始处理"
- `ack`：STM32 执行完成后发送，表示"命令执行完成"，携带执行结果

### 2.2 完整命令流程图

```
App                    Server                  ESP32                   STM32
 │                       │                       │                       │
 │ ① 命令                │                       │                       │
 │   seq_id=xxx          │                       │                       │
 │──────────────────────>│                       │                       │
 │                       │                       │                       │
 │ ② server_ack          │                       │                       │
 │   seq_id=xxx          │                       │                       │
 │<──────────────────────│                       │                       │
 │                       │                       │                       │
 │                       │ ③ 命令转发            │                       │
 │                       │   seq_id=xxx          │                       │
 │                       │──────────────────────>│                       │
 │                       │                       │                       │
 │                       │ ④ esp32_ack           │                       │
 │                       │   seq_id=xxx          │  ← 第二级：命令已收到  │
 │                       │<──────────────────────│                       │
 │                       │                       │                       │
 │                       │                       │ ⑤ UART 命令           │
 │                       │                       │──────────────────────>│
 │                       │                       │                       │
 │                       │                       │                       │ ⑥ 执行
 │                       │                       │                       │
 │                       │                       │ ⑦ UART 响应           │
 │                       │                       │<──────────────────────│
 │                       │                       │                       │
 │                       │ ⑧ ack                 │                       │
 │                       │   seq_id=xxx          │  ← 第三级：执行完成    │
 │                       │   code=0/错误码       │                       │
 │                       │<──────────────────────│                       │
 │                       │                       │                       │
 │ ⑨ ack 转发            │                       │                       │
 │   seq_id=xxx          │                       │                       │
 │<──────────────────────│                       │                       │
 │                       │                       │                       │
 │ ⑩ 确认执行结果        │                       │                       │
```

### 2.3 重试机制（重要）

**核心原则**：各端内部重试对上层透明，只返回最终结果。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           重试机制分层                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  App ←──────────────→ Server                                            │
│       │                                                                 │
│       │  App 重试：3秒超时，最多3次                                      │
│       │  Server 内部重试对 App 透明                                      │
│       │  App 只收到最终的 server_ack 和 ack                              │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Server ←──────────────→ ESP32                                          │
│          │                                                              │
│          │  Server 重试：2秒超时，最多3次                                │
│          │  ESP32 内部重试对 Server 透明                                 │
│          │  Server 只收到最终的 esp32_ack 和 ack                         │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ESP32 ←──────────────→ STM32                                           │
│         │                                                               │
│         │  ESP32 重试：1秒超时，最多3次                                  │
│         │  STM32 无重试概念                                              │
│         │  ESP32 只向 Server 报告最终结果（成功/失败）                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**示例：ESP32 对 STM32 的重试**

```
ESP32                                STM32
 │                                     │
 │ UART 命令 (第1次)                   │
 │────────────────────────────────────>│
 │                                     │
 │     ... 1秒无响应 ...               │
 │                                     │
 │ UART 命令 (第2次，重试)             │
 │────────────────────────────────────>│
 │                                     │
 │ ACK_OK                              │
 │<────────────────────────────────────│
 │                                     │
 │ 向 Server 报告成功                  │
 │ (Server 不知道重试了几次)           │
```

### 2.4 统一错误码定义

#### 2.4.1 设计原则

**全局统一**：所有层（Server、ESP32、STM32）共用一套错误码，App 端无需关心错误来源。

#### 2.4.2 统一错误码表

| code | 含义 | 说明 | 可能来源 |
|------|------|------|----------|
| 0 | 成功 | 操作成功完成 | 所有层 |
| 1 | 设备离线 | ESP32 未连接服务器 | Server |
| 2 | 设备忙 | 正在执行其他操作 | ESP32/STM32 |
| 3 | 参数错误 | 命令格式或参数无效 | 所有层 |
| 4 | 不支持 | 不支持的命令或操作 | ESP32/STM32 |
| 5 | 超时 | 等待响应超时 | 所有层 |
| 6 | 硬件故障 | 硬件异常或不可用 | ESP32/STM32 |
| 7 | 资源已满 | 指纹/NFC 存储已满 | STM32 |
| 8 | 未认证 | 用户未登录或权限不足 | Server |
| 9 | 重复消息 | seq_id 重复（防重放） | Server/ESP32 |
| 10 | 内部错误 | 未知内部异常 | 所有层 |

#### 2.4.3 STM32 错误码映射

ESP32 负责将 STM32 的 UART 错误码映射为统一错误码：

| STM32 错误码 | 宏定义 | 统一 code | 说明 |
|--------------|--------|-----------|------|
| 0x01 | ERR_BUSY | 2 | 设备忙 |
| 0x02 | ERR_UNSUPPORT | 4 | 不支持 |
| 0x03 | ERR_PARAM | 3 | 参数错误 |
| 0x04 | ERR_FP_FULL | 7 | 指纹库满 |
| 0x05 | ERR_NFC_FULL | 7 | NFC 库满 |
| 0x06 | ERR_HARDWARE | 6 | 硬件故障 |
| 0xFF | ERR_TIMEOUT | 5 | 超时 |

#### 2.4.4 错误码映射函数

```cpp
// ESP32 端：STM32 错误码 → 统一错误码
int MapStm32ErrorCode(uint8_t stm32_err) {
    switch (stm32_err) {
        case 0x01: return 2;   // ERR_BUSY → 设备忙
        case 0x02: return 4;   // ERR_UNSUPPORT → 不支持
        case 0x03: return 3;   // ERR_PARAM → 参数错误
        case 0x04: return 7;   // ERR_FP_FULL → 资源已满
        case 0x05: return 7;   // ERR_NFC_FULL → 资源已满
        case 0x06: return 6;   // ERR_HARDWARE → 硬件故障
        case 0xFF: return 5;   // ERR_TIMEOUT → 超时
        default:   return 10;  // 未知 → 内部错误
    }
}
```

#### 2.4.5 App 端错误处理建议

| code | 用户提示 | 建议操作 |
|------|----------|----------|
| 0 | 操作成功 | - |
| 1 | 设备离线，请检查网络 | 检查设备网络连接 |
| 2 | 设备忙，请稍后重试 | 等待几秒后重试 |
| 3 | 参数错误 | 检查输入参数 |
| 4 | 不支持此操作 | 检查设备功能 |
| 5 | 操作超时，请重试 | 重新发送命令 |
| 6 | 硬件故障，请联系维修 | 检查硬件状态 |
| 7 | 存储已满，请先删除 | 删除旧数据后重试 |
| 8 | 请先登录 | 重新登录 |
| 9 | 请勿重复操作 | 忽略 |
| 10 | 系统错误，请重试 | 稍后重试 |

---

## 三、App ↔ Server 通信详解

### 3.1 通信协议

| 项目 | 说明 |
|------|------|
| 协议 | WebSocket |
| 数据格式 | JSON |
| 消息标识 | seq_id（App 生成） |

### 3.2 消息类型

**App → Server**：

| 类型 | 说明 | 示例 |
|------|------|------|
| `lock_control` | 锁控命令 | unlock, lock |
| `user_mgmt` | 用户管理 | finger.add, nfc.del |
| `query` | 查询请求 | sensors, status |
| `dev_control` | 设备控制 | beep, oled, light |

**Server → App**：

| 类型 | 说明 | 携带 seq_id |
|------|------|-------------|
| `server_ack` | 服务器确认 | ✅ |
| `esp32_ack` | ESP32 收到确认（转发） | ✅ |
| `ack` | 执行完成确认（转发） | ✅ |
| `event` | 事件推送 | ❌ |

### 3.3 确认机制

```
App                                Server
 │                                   │
 │ 命令 (seq_id=xxx)                 │
 │──────────────────────────────────>│
 │                                   │
 │ server_ack (seq_id=xxx)           │  ← 第一级：服务器已收到
 │<──────────────────────────────────│
 │                                   │
 │ esp32_ack (seq_id=xxx)            │  ← 第二级：ESP32 已收到
 │<──────────────────────────────────│
 │                                   │
 │     ... 等待 STM32 执行 ...       │
 │                                   │
 │ ack (seq_id=xxx, code=0)          │  ← 第三级：执行完成
 │<──────────────────────────────────│
```

### 3.4 App 端超时与重试

| 阶段 | 超时时间 | 重试次数 | 说明 |
|------|----------|----------|------|
| 等待 server_ack | 3 秒 | 3 次 | 未收到则重发命令 |
| 等待 esp32_ack | 5 秒 | 不重试 | 由 Server 处理 |
| 等待 ack | 根据命令类型 | 不重试 | 由 Server 处理 |

**命令类型超时**：

| 命令类型 | 超时时间 | 示例 |
|----------|----------|------|
| 即时命令 | 5 秒 | unlock, beep |
| 查询命令 | 10 秒 | sensors, status |
| 长流程命令 | 60 秒 | finger.add, nfc.add |

---

## 四、Server ↔ ESP32 通信详解

### 4.1 通信协议

| 项目 | 说明 |
|------|------|
| 协议 | WebSocket |
| 数据格式 | JSON |
| 消息标识 | seq_id（透传自 App） |

### 4.2 消息类型

**Server → ESP32**：

| 类型 | 说明 | 携带 seq_id |
|------|------|-------------|
| `lock_control` | 锁控命令 | ✅ |
| `user_mgmt` | 用户管理 | ✅ |
| `query` | 查询请求 | ✅ |
| `dev_control` | 设备控制 | ✅ |

**ESP32 → Server**：

| 类型 | 说明 | 携带 seq_id |
|------|------|-------------|
| `esp32_ack` | 命令已收到确认 | ✅ |
| `ack` | 执行完成确认 | ✅ |
| `event` | 事件上报 | ❌ |
| `query_result` | 查询结果 | ✅ |

### 4.3 两级确认机制

```json
// esp32_ack：命令已收到，开始处理
{
    "type": "esp32_ack",
    "seq_id": "1702234567890_0",
    "code": 0,
    "msg": "received"
}

// ack：执行完成
{
    "type": "ack",
    "seq_id": "1702234567890_0",
    "code": 0,
    "msg": "OK"
}
```

### 4.4 ESP32 待处理命令队列

ESP32 需要维护待处理命令队列，用于关联 STM32 响应与原始 seq_id：

```cpp
struct PendingCommand {
    std::string seq_id;       // 原始消息 ID
    uint8_t uart_type;        // UART 命令 TYPE
    int64_t timestamp_ms;     // 发送时间戳
    bool esp32_ack_sent;      // 是否已发送 esp32_ack
};
```

**工作流程**：

1. 收到 Server 命令 → 发送 `esp32_ack`（携带 seq_id）
2. 保存 {uart_type → seq_id} 映射
3. 发送 UART 命令到 STM32
4. 收到 STM32 响应 → 通过 uart_type 查找 seq_id
5. 发送 `ack`（携带 seq_id 和执行结果）

### 4.5 Server 端超时与重试

| 阶段 | 超时时间 | 重试次数 | 说明 |
|------|----------|----------|------|
| 等待 esp32_ack | 2 秒 | 3 次 | 未收到则重发命令 |
| 等待 ack | 根据命令类型 | 不重试 | 超时则通知 App |

**重要**：Server 的重试对 App 透明，App 只收到最终结果。

---

## 五、ESP32 ↔ STM32 通信详解

### 5.1 通信协议

| 项目 | 说明 |
|------|------|
| 协议 | UART |
| 波特率 | 9600 bps |
| 帧格式 | 7 字节固定长度 |
| 消息标识 | 无（通过 TYPE 匹配） |

### 5.2 帧格式

```
[0xAA] [CAT] [TYPE] [D0] [D1] [D2] [CHECKSUM]
  │      │     │     └─── 3字节载荷 ───┘    │
 帧头   大类  指令字                       校验和
```

### 5.3 ACK 响应策略

| 策略 | 说明 | 适用命令 |
|------|------|----------|
| 执行后 ACK | 执行完成后回复 | unlock, beep, oled |
| 先 ACK 后数据 | 先 ACK，再发数据帧 | sensors, status |
| 先 ACK 后上报 | 先 ACK，过程上报 | finger.add, nfc.add |

### 5.4 命令分类与超时

| 类型 | 超时时间 | 重试次数 | 示例 |
|------|----------|----------|------|
| 即时命令 | 1 秒 | 3 次 | CMD_LOCK, CMD_BEEP |
| 查询命令 | 2 秒 | 2 次 | Q_SENSORS, Q_STATUS |
| 长流程命令 | 60 秒 | 不重试 | 指纹录入, NFC 录入 |

### 5.5 ESP32 重试机制

**核心原则**：ESP32 对 STM32 的重试对 Server 透明。

```
ESP32                                STM32
 │                                     │
 │ UART 命令 (第1次)                   │
 │────────────────────────────────────>│
 │                                     │
 │     ... 1秒无响应 ...               │
 │                                     │
 │ UART 命令 (第2次)                   │
 │────────────────────────────────────>│
 │                                     │
 │ ACK_OK                              │
 │<────────────────────────────────────│
 │                                     │
 │ 向 Server 报告成功                  │
 │ (Server 不知道重试了几次)           │
```

### 5.6 STM32 响应与 seq_id 关联

由于 UART 协议不支持消息 ID，ESP32 通过 TYPE 字段匹配：

| STM32 响应 | TYPE | 对应命令 | ESP32 处理 |
|------------|------|----------|------------|
| ACK_OK | 0x10 | CMD_LOCK | 查找 pending[0x10].seq_id |
| FP_RESP | 0x11 | FP_CMD | 查找 pending[0x10].seq_id |
| NFC_RESP | 0x21 | NFC_CMD | 查找 pending[0x20].seq_id |
| RPT_ENV | 0xB0 | Q_SENSORS | 查找 pending[0x80].seq_id |

---

## 六、消息类型与命令分类

### 6.1 锁控命令 (lock_control)

| 命令 | STM32 TYPE | ACK 策略 | 说明 |
|------|------------|----------|------|
| unlock | CMD_LOCK (0x10) | 执行后 ACK | 开锁 |
| lock | CMD_LOCK (0x10) | 执行后 ACK | 关锁 |
| temp_code | TEMP_PWD (0x32+0x33) | 两包 ACK | 临时密码 |

### 6.2 用户管理命令 (user_mgmt)

| 命令 | STM32 TYPE | ACK 策略 | 说明 |
|------|------------|----------|------|
| finger.add | FP_CMD (0x10) | 先 ACK 后上报 | 指纹录入 |
| finger.del | FP_CMD (0x10) | 执行后 ACK | 删除指纹 |
| finger.clear | FP_CMD (0x10) | 执行后 ACK | 清空指纹 |
| finger.query | FP_CMD (0x10) | 先 ACK 后数据 | 查询数量 |
| nfc.add | NFC_CMD (0x20) | 先 ACK 后上报 | NFC 录入 |
| nfc.del | NFC_CMD (0x20) | 执行后 ACK | 删除 NFC |
| nfc.clear | NFC_CMD (0x20) | 执行后 ACK | 清空 NFC |
| nfc.query | NFC_CMD (0x20) | 先 ACK 后数据 | 查询数量 |
| password.set | PWD_SET (0x30) | 执行后 ACK | 设置密码 |
| password.query | PWD_QUERY (0x31) | 先 ACK 后数据 | 查询密码 |

### 6.3 查询命令 (query)

| 命令 | STM32 TYPE | 数据帧 | 说明 |
|------|------------|--------|------|
| sensors | Q_SENSORS (0x80) | RPT_ENV (0xB0) | 传感器数据 |
| status | Q_STATUS (0x81) | RPT_STATE (0xB1) | 设备状态 |

### 6.4 设备控制命令 (dev_control)

| 命令 | STM32 TYPE | ACK 策略 | 说明 |
|------|------------|----------|------|
| beep | CMD_BEEP (0x12) | 执行后 ACK | 蜂鸣器 |
| oled | CMD_OLED (0x11) | 执行后 ACK | OLED 显示 |
| light | CMD_LIGHT (0x14) | 执行后 ACK | 补光灯 |

---

## 七、实现状态

### 7.1 已实现

| 模块 | 状态 | 说明 |
|------|------|------|
| App seq_id 生成 | ✅ | 时间戳_序号格式 |
| App server_ack 处理 | ✅ | 超时重试 |
| Server 消息转发 | ✅ | seq_id 透传 |
| ESP32 防重放检查 | ✅ | 100 条缓存 |
| ESP32 esp32_ack | ✅ | 收到命令后立即发送（v5.2 实现） |
| ESP32 ack | ✅ | 执行完成后发送（v5.2 实现） |
| ESP32 待处理命令队列 | ✅ | pending_commands_ 映射表（v5.2 实现） |
| ESP32 query 命令处理 | ✅ | sensors/status 查询（v5.2 实现） |
| ESP32 face_result 两级确认 | ✅ | esp32_ack + ack（v5.2 实现） |

### 7.2 待实现

| 功能 | 优先级 | 说明 |
|------|--------|------|
| 统一错误码映射 | P0 | STM32 → WebSocket（部分实现） |
| 超时清理机制 | P1 | 防止内存泄漏 |
| 并发命令检测 | P1 | 返回 DEVICE_BUSY |

---

## 八、版本历史

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| v2.4 | 2026-01-16 | 更新实现状态：esp32_ack、ack、待处理命令队列、query 命令、face_result 两级确认已实现 |
| v2.3 | 2026-01-13 | 统一错误码：所有层共用一套错误码（0-10），App 无需关心错误来源 |
| v2.2 | 2026-01-13 | ESP32 统一使用 seq_id；区分 esp32_ack（收到）和 ack（完成） |
| v2.1 | 2026-01-13 | 重构文档结构：整体流程 + 分段详解；明确重试机制对上层透明原则 |
| v2.0 | 2026-01-13 | 新增两级确认机制设计 |
| v1.0 | 2026-01-12 | 初始版本（App 端协议总结） |

---

**文档维护者**：毕业设计项目组  
**最后更新**：2026-01-16
