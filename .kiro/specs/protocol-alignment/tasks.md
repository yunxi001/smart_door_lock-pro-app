# 实现计划：协议对齐

## 概述

本实现计划将 DeviceService.ts 修改为完全符合智能门锁通信协议规范 v2.3。任务按照依赖关系组织，确保每个步骤都可以独立验证。

## 任务列表

- [x] 1. 修复 hello 消息和 seq_id 生成
  - [x] 1.1 在 connect() 方法中添加 appId 参数
    - 修改 connect() 方法签名：`connect(url: string, deviceId: string, appId: string)`
    - 在 hello 消息中添加 app_id 字段
    - _需求：1.1, 1.2, 1.3_
  - [x] 1.2 修复 seq_id 生成器格式
    - 添加 lastSeqTimestamp 属性追踪时间戳变化
    - 修改 generateSeqId() 方法：当时间戳变化时重置 seqCounter
    - 确保格式为 `{timestamp}_{sequence}`，无任何前缀
    - _需求：13.1, 13.2, 13.3, 13.4, 13.5_

- [x] 2. 实现两级确认机制
  - [x] 2.1 完善 handleServerAck() 方法
    - 处理 code=0：继续等待 ack，不清理队列
    - 处理 code=1-4：清理队列，触发 onError 回调
    - 处理 code=5（重复消息）：清理队列但不触发 onError
    - 添加日志记录
    - _需求：2.1, 2.2, 2.3, 2.4, 18.1, 18.2, 18.3_
  - [x] 2.2 完善 handleAck() 方法
    - 清除超时计时器
    - 根据 code 触发 onSuccess 或 onError
    - 从 pendingCommands 中移除命令
    - 调用 getAckErrorMessage() 获取错误描述
    - _需求：3.1, 3.2, 3.3, 14.5_

- [x] 3. 完善错误码映射
  - [x] 3.1 更新 getAckErrorMessage() 方法
    - 添加完整的 0-10 错误码映射
    - 错误码映射：0=成功, 1=设备离线, 2=设备忙碌, 3=参数错误, 4=不支持, 5=超时, 6=硬件故障, 7=资源已满, 8=未认证, 9=重复消息, 10=内部错误
    - 返回中文错误描述
    - _需求：3.1, 3.2, 3.3_
  - [x] 3.2 添加用户友好的错误提示
    - 设备离线：提示"请检查网络连接"
    - 设备忙碌：提示"请稍后重试"
    - 硬件故障：提示"请联系维修"
    - _需求：19.1, 19.2, 19.3, 19.4, 19.5_

- [x] 4. 新增事件类型支持
  - [x] 4.1 更新 handleEventReport() 方法
    - 添加 door_closed 事件处理：显示"门已关闭"
    - 添加 lock_success 事件处理：显示"上锁成功"
    - 添加 bolt_alarm 事件处理：显示"锁舌上锁失败，请尝试远程上锁"
    - 确保所有事件触发 event_report 事件和日志
    - _需求：4.1, 4.2, 4.3, 4.4, 4.5_

- [x] 5. 修复 log_report 字段名称
  - [x] 5.1 更新 handleLogReport() 方法
    - 将 data.result 改为 data.status
    - 将 data.fail_count 改为 data.lock_time
    - 处理 status 值：'success', 'fail', 'locked'
    - 更新日志消息生成逻辑
    - _需求：7.1, 7.2, 7.3, 7.4_
  - [x] 5.2 更新 types.ts 中的 UnlockLog 接口
    - 将 result: boolean 改为 status: string
    - 添加 lock_time: number 字段
    - 保持向后兼容（可选）
    - _需求：7.1, 7.2_

- [x] 6. 实现新消息类型处理
  - [x] 6.1 实现 handleDoorOpenedReport() 方法
    - 解析 method 和 source 字段
    - 触发 door_opened_report 事件
    - 记录日志：显示开门方式和来源（外侧/内侧/未知）
    - _需求：5.1, 5.2, 5.3, 5.4_
  - [x] 6.2 实现 handlePasswordReport() 方法
    - 解析 password 字段
    - 触发 password_report 事件
    - 将密码数据传递给订阅者
    - 不存储到数据库（仅用于查询结果）
    - _需求：6.1, 6.2, 6.3, 6.4_
  - [x] 6.3 在 handleTextMessage() 中添加消息路由
    - 添加 door_opened_report 消息类型判断
    - 添加 password_report 消息类型判断
    - 调用对应的处理方法
    - _需求：5.1, 6.1_

- [x] 7. 检查点 - 核心功能验证
  - 确保所有测试通过
  - 验证 hello 消息包含 app_id
  - 验证 seq_id 格式正确
  - 验证两级确认机制工作正常
  - 如有问题，询问用户

- [x] 8. 实现 user_mgmt 命令支持
  - [x] 8.1 验证 sendUserMgmtCommand() 方法
    - 确认方法已存在（当前代码已实现）
    - 验证支持 finger、nfc、password 三种 category
    - 验证支持 add、del、clear、query、set 五种 command
    - 验证 payload 字段在 category=password 且 command=set 时添加
    - _需求：8.1, 8.2, 8.3, 8.4_

- [x] 9. 实现 query 命令支持
  - [x] 9.1 添加 sendQuery() 方法
    - 接受 target 参数：status, status_history, events, unlock_logs, media_files
    - 接受可选的 data 参数（包含 limit, offset 等分页参数）
    - 使用 sendCommand() 发送消息
    - _需求：9.1, 9.2, 9.3_
  - [x] 9.2 验证 handleQueryResult() 方法
    - 确认方法已存在（当前代码已实现）
    - 验证根据 target 触发对应事件
    - 验证错误处理
    - _需求：9.4_

- [x] 10. 实现 face_management 命令支持
  - [x] 10.1 添加 sendFaceManagement() 方法
    - 接受 action 参数：register, get_persons, delete_person, update_permission, get_visits
    - 接受可选的 data 参数
    - 对于 register 操作，验证包含 name, relation_type, images, permission 字段
    - 使用 sendCommand() 发送消息
    - _需求：10.1, 10.2, 10.3_
  - [x] 10.2 验证 face_management 响应处理
    - 确认 handleTextMessage() 中已处理 face_management 响应
    - 验证触发 face_response 事件
    - _需求：10.4_

- [x] 11. 实现 media_download 功能
  - [x] 11.1 验证 sendMediaDownload() 方法
    - 确认方法已存在（当前代码已实现）
    - 验证支持通过 file_id 下载
    - 添加支持通过 file_path 下载
    - _需求：11.1_
  - [x] 11.2 验证 sendMediaDownloadChunk() 方法
    - 确认方法已存在（当前代码已实现）
    - 验证支持分片下载（file_id, chunk_index, chunk_size）
    - _需求：11.3_
  - [x] 11.3 验证媒体下载响应处理
    - 确认 handleMediaDownload() 已实现
    - 确认 handleMediaDownloadChunk() 已实现
    - 验证 Base64 解码和下载完成事件触发
    - _需求：11.4_

- [x] 12. 实现 system 命令支持
  - [x] 12.1 添加 sendSystemCommand() 方法
    - 支持 start_monitor 命令（包含 record 字段）
    - 支持 stop_monitor 命令
    - 使用 sendCommand() 发送（支持 seq_id 和重试）
    - _需求：12.1, 12.2, 12.4_
  - [x] 12.2 验证 system 响应处理
    - 确认 handleTextMessage() 中已处理 system 响应
    - 验证根据 status 字段显示成功或失败
    - _需求：12.3_

- [x] 13. 检查点 - 命令功能验证
  - 确保所有命令方法可用
  - 验证消息格式符合协议规范
  - 测试每个命令的发送和响应
  - 如有问题，询问用户

- [x] 14. 完善超时和重试机制
  - [x] 14.1 验证 handleTimeout() 方法
    - 确认超时时间为 3 秒
    - 确认最大重试次数为 3 次
    - 确认重传时使用相同的 seq_id
    - 确认超过最大重试次数后触发错误回调
    - _需求：14.1, 14.2, 14.3, 14.4_
  - [x] 14.2 验证 server_ack code=0 时的行为
    - 确认收到 server_ack (code=0) 后继续等待 ack
    - 确认不清理等待队列
    - _需求：14.5_

- [x] 15. 实现设备上下线通知处理
  - [x] 15.1 验证 handleDeviceStatus() 方法
    - 确认方法已存在（当前代码已实现）
    - 验证 status='online' 时显示"设备已上线"
    - 验证 status='offline' 时显示"设备已离线"
    - 验证触发 device_status 事件
    - _需求：15.1, 15.2, 15.4_
  - [x] 15.2 添加 UI 状态更新逻辑
    - 在 App.tsx 中订阅 device_status 事件
    - 设备离线时禁用操作按钮
    - 设备上线时启用操作按钮
    - _需求：15.3_

- [x] 16. 升级音频 API
  - [x] 16.1 实现 AudioWorklet 支持
    - 创建 AudioWorklet 处理器文件
    - 在 startTalk() 中检测 AudioWorklet 支持
    - 优先使用 AudioWorklet 进行音频采集
    - _需求：16.1_
  - [x] 16.2 实现降级方案
    - 当 AudioWorklet 不支持时，使用 ScriptProcessorNode
    - 确保两种方案功能一致
    - _需求：16.2_
  - [x] 16.3 验证音频播放功能
    - 确认继续使用 AudioContext 和 AudioBufferSourceNode
    - 确认不产生弃用警告
    - _需求：16.3, 16.4_

- [x] 17. 完善日志记录
  - [x] 17.1 添加命令发送日志
    - 在 sendCommand() 中记录 type 和 seq_id
    - 格式：`发送命令: {type} (seq_id: {seq_id})`
    - _需求：17.1_
  - [x] 17.2 添加响应接收日志
    - 在 handleServerAck() 中记录 type, seq_id, code
    - 在 handleAck() 中记录 type, seq_id, code
    - 格式：`收到响应: {type} (seq_id: {seq_id}, code: {code})`
    - _需求：17.2_
  - [x] 17.3 添加重传日志
    - 在 handleTimeout() 中记录重传次数
    - 格式：`命令超时，正在重传 ({retryCount}/{maxRetries})`
    - _需求：17.3_
  - [x] 17.4 统一日志格式
    - 确保所有日志使用一致的格式
    - 便于追踪和调试
    - _需求：17.4_

- [x] 18. 验证防重放机制
  - [x] 18.1 验证 server_ack code=5 处理
    - 确认收到 code=5 时清理等待队列
    - 确认不触发 onError 回调
    - 确认不记录错误日志
    - _需求：18.1_
  - [x] 18.2 验证重传使用相同 seq_id
    - 确认重传时不生成新的 seq_id
    - 允许服务器检测重复消息
    - _需求：18.3_

- [x] 19. 编写单元测试
  - [ ]\* 19.1 测试 seq_id 唯一性（属性 1）
    - 生成 1000 个命令，验证所有 seq_id 唯一
    - 在同一毫秒内发送 10 个命令，验证序号递增
    - **属性 1: seq_id 唯一性**
    - **验证需求：1.1, 1.2, 13.1, 13.2, 13.3, 13.4, 13.5**
  - [ ]\* 19.2 测试 seq_id 格式正确性（属性 2）
    - 验证所有生成的 seq*id 匹配正则表达式 `/^\d{13}*\d+$/`
    - 验证 `1702234567890_0` 格式正确
    - 验证 `app_1702234567890_0` 格式错误
    - **属性 2: seq_id 格式正确性**
    - **验证需求：13.1, 13.2, 13.3**
  - [ ]\* 19.3 测试命令超时重传（属性 3）
    - 模拟服务器不响应，验证重传 3 次后触发错误回调
    - 验证重传时使用相同的 seq_id
    - **属性 3: 命令超时重传**
    - **验证需求：14.1, 14.2, 14.3, 14.4, 14.5**
  - [ ]\* 19.4 测试 server_ack 处理正确性（属性 4）
    - 发送命令，收到 server_ack (code=0)，验证命令仍在队列中
    - 发送命令，收到 server_ack (code=1)，验证命令被移除且触发错误回调
    - 发送命令，收到 server_ack (code=5)，验证命令被移除但不触发错误回调
    - **属性 4: server_ack 处理正确性**
    - **验证需求：2.1, 2.2, 2.3, 2.4, 18.1, 18.2, 18.3**
  - [ ]\* 19.5 测试 ack 处理正确性（属性 5）
    - 发送命令，收到 ack (code=0)，验证触发 onSuccess 回调
    - 发送命令，收到 ack (code=6)，验证触发 onError 回调并显示"硬件故障"
    - **属性 5: ack 处理正确性**
    - **验证需求：3.1, 3.2, 3.3**
  - [ ]\* 19.6 测试错误码映射完整性（属性 6）
    - 验证 ACK_ERRORS 包含 0-10 所有错误码
    - 验证每个错误码对应的描述为非空中文字符串
    - **属性 6: 错误码映射完整性**
    - **验证需求：3.1, 3.2, 3.3**
  - [ ]\* 19.7 测试 hello 消息包含 app_id（属性 7）
    - 调用 connect()，验证发送的 hello 消息包含 app_id 字段
    - **属性 7: hello 消息包含 app_id**
    - **验证需求：1.1, 1.2, 1.3**
  - [ ]\* 19.8 测试事件类型完整性（属性 8）
    - 模拟收到 door_closed 事件，验证触发"门已关闭"日志
    - 模拟收到 lock_success 事件，验证触发"上锁成功"日志
    - 模拟收到 bolt_alarm 事件，验证触发"锁舌上锁失败，请尝试远程上锁"日志
    - **属性 8: 事件类型完整性**
    - **验证需求：4.1, 4.2, 4.3, 4.4, 4.5**
  - [ ]\* 19.9 测试 log_report 字段正确性（属性 9）
    - 模拟收到 log_report 消息，验证正确读取 status 字段
    - 验证 status='success' 时显示"成功"，status='fail' 时显示"失败"
    - **属性 9: log_report 字段正确性**
    - **验证需求：7.1, 7.2, 7.3, 7.4**
  - [ ]\* 19.10 测试新消息类型支持（属性 10）
    - 模拟收到 door_opened_report 消息，验证触发对应事件
    - 模拟收到 password_report 消息，验证触发对应事件
    - **属性 10: 新消息类型支持**
    - **验证需求：5.1, 5.2, 5.3, 5.4, 6.1, 6.2, 6.3, 6.4**
  - [ ]\* 19.11 测试设备上下线通知（属性 11）
    - 模拟收到 online 消息，验证触发"设备已上线"日志
    - 模拟收到 offline 消息，验证触发"设备已离线"日志
    - **属性 11: 设备上下线通知**
    - **验证需求：15.1, 15.2, 15.3, 15.4**
  - [ ]\* 19.12 测试命令方法完整性（属性 12）
    - 验证所有方法存在且可调用
    - 调用每个方法，验证发送的消息格式正确
    - **属性 12: 命令方法完整性**
    - **验证需求：8.1, 8.2, 8.3, 8.4, 9.1, 9.2, 9.3, 9.4, 10.1, 10.2, 10.3, 10.4, 11.1, 11.2, 11.3, 11.4**
  - [ ]\* 19.13 测试日志记录完整性（属性 14）
    - 发送命令，验证触发日志事件
    - 收到响应，验证触发日志事件
    - 超时重传，验证触发日志事件
    - **属性 14: 日志记录完整性**
    - **验证需求：17.1, 17.2, 17.3, 17.4**
  - [ ]\* 19.14 测试错误提示友好性（属性 15）
    - 验证设备离线时提示"请检查网络连接"
    - 验证设备忙碌时提示"请稍后重试"
    - 验证硬件故障时提示"请联系维修"
    - **属性 15: 错误提示友好性**
    - **验证需求：19.1, 19.2, 19.3, 19.4, 19.5**

- [x] 20. 最终检查点
  - 运行所有测试
  - 验证所有需求已实现
  - 检查代码质量和注释
  - 确认无 TypeScript 错误
  - 确认无浏览器控制台警告
  - 如有问题，询问用户

## 注意事项

1. **测试优先**：每完成一个任务，立即验证功能是否正常
2. **增量提交**：每个任务完成后提交代码，便于回滚
3. **向后兼容**：尽量保持与现有代码的兼容性
4. **错误处理**：所有网络操作都要有错误处理
5. **日志记录**：关键操作都要记录日志，便于调试
6. **代码注释**：使用中文注释说明关键逻辑

## 依赖关系

- 任务 1-6 是核心功能，必须优先完成
- 任务 7 是第一个检查点，确保核心功能正常
- 任务 8-12 是命令扩展，可以并行开发
- 任务 13 是第二个检查点，确保命令功能正常
- 任务 14-18 是优化改进，依赖核心功能
- 任务 19 是最终验证

## 测试说明

所有测试任务（19.1-19.14）都标记为可选（`*`），因为：

1. 测试任务是验证性质的，不是核心实现
2. 可以在实现完成后集中编写测试
3. 每个测试任务都对应设计文档中的正确性属性
4. 测试任务使用 Jest 测试框架

如果需要完整的测试覆盖，可以将这些任务标记为必需。

## 预计工作量

- 核心修复（任务 1-6）：4-6 小时
- 命令扩展（任务 8-12）：3-4 小时
- 优化改进（任务 14-18）：2-3 小时
- 单元测试（任务 19）：4-6 小时
- 最终验证（任务 20）：1-2 小时
- 总计：14-21 小时
